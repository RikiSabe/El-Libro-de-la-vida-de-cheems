struct Node {
    ll min_val = infL;  
    ll propagate = 0;
};

Node ST[4 * N];

void propagate(int node, int start, int end) {
    if (ST[node].propagate != 0) {
        ST[node].min_val += ST[node].propagate;
        
        if (start != end) {
            ST[2 * node + 1].propagate += ST[node].propagate;
            ST[2 * node + 2].propagate += ST[node].propagate;
        }

        ST[node].propagate = 0;
    }
}

void build(const vector<ll>& arr, int node, int start, int end) {
    if (start == end) {
        ST[node].min_val = arr[start];
    } else {
        int mid = (start + end) / 2;
        build(arr, 2 * node + 1, start, mid);
        build(arr, 2 * node + 2, mid + 1, end);
        ST[node].min_val = min(ST[2 * node + 1].min_val, ST[2 * node + 2].min_val);
    }
}

ll query(int node, int start, int end, int L, int R) {
    propagate(node, start, end);
    
    if (start > R || end < L) {
        return infL;
    }

    if (start >= L && end <= R) {
        return ST[node].min_val;
    }

    int mid = (start + end) / 2;
    ll left_query = query(2 * node + 1, start, mid, L, R);
    ll right_query = query(2 * node + 2, mid + 1, end, L, R);
    
    return min(left_query, right_query);
}

void update_range(int node, int start, int end, int L, int R, ll value) {
    propagate(node, start, end);
    
    if (start > R || end < L) {
        return;
    }

    if (start >= L && end <= R) {
        ST[node].propagate += value;
        propagate(node, start, end);
        return;
    }

    int mid = (start + end) / 2;
    update_range(2 * node + 1, start, mid, L, R, value);
    update_range(2 * node + 2, mid + 1, end, L, R, value);
    
    ST[node].min_val = min(ST[2 * node + 1].min_val, ST[2 * node + 2].min_val);
}

void cumbia420PaLosCheems(int testCase) {
	int n; cin >> n;
	vector<ll> A(n, 0);
	FOR(i, 0, n) cin >> A[i];
	build(A, 0, 0, n - 1);

	while (1) {
        int op;
        cin >> op;
        if (op == 1) {  // Consulta de mínimo en el rango [L, R]
            int L, R;
            cin >> L >> R;
            cout << query(0, 0, n - 1, L, R) << endl;
        } else if (op == 2) {  // Actualización de rango con suma
            int L, R;
            ll v;
            cin >> L >> R >> v;
            update_range(0, 0, n - 1, L, R, v);
        }
    }
}
